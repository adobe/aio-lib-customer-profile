class CustomerProfileAPI {
  
  /**
   * Retrieve a list of computed attributes.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @returns {Promise<Response>} the response
   */
  listComputedAttributes (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create a computed attribute.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @returns {Promise<Response>} the response
   */
  createComputedAttribute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Retrieve a specific computed attribute by its ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.ATTRIBUTE_ID - The unique, read-only ID of the computed attribute that is generated by the system when the attribute is created.
   * @returns {Promise<Response>} the response
   */
  lookupComputedAttribute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Update a computed attribute by its ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.ATTRIBUTE_ID - The unique, read-only ID of the computed attribute that is generated by the system when the attribute is created.
   * @returns {Promise<Response>} the response
   */
  updateComputedAttribute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Delete a computed attribute by its ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.ATTRIBUTE_ID - The unique, read-only ID of the computed attribute that is generated by the system when the attribute is created.
   * @returns {Promise<Response>} the response
   */
  deleteComputedAttribute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Retrieve a list of merge policies.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} [parameters.'x-request-id'] - Request Id
   * @param {string} [parameters.start] - Page offset - As per created time of resource
   * @param {number} [parameters.limit] - Page Size
   * @param {string} [parameters.orderBy] - Model attribute which will be using for ordering
   * @param {string} [parameters.'schema.name'] - Schema class ID
   * @param {boolean} [parameters.default] - default flag
   * @returns {Promise<Response>} the response
   */
  getConfigMergePolicies (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create a new merge policy.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'Content-Type' - Type of content being sent in the body of the request. Should be 'application/json'.
   * @param {string} parameters.'x-profile-instance-id' - Profile Instance ID
   * @param {string} [parameters.'x-request-id'] - Request Id
   * @returns {Promise<Response>} the response
   */
  postConfigMergePolicies (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup a merge policy by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.mergePolicyId - Merge policy ID.
   * @param {string} [parameters.'x-request-id'] - Request Id
   * @returns {Promise<Response>} the response
   */
  getConfigMergePoliciesMergePolicyId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Update a merge policy by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.mergePolicyId - Merge policy ID.
   * @param {string} parameters.'x-profile-instance-id' - Profile Instance ID
   * @param {string} [parameters.'x-request-id'] - Request Id
   * @returns {Promise<Response>} the response
   */
  putConfigMergePoliciesMergePolicyId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Update one or more attributes of a merge policy specified by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.mergePolicyId - Merge policy ID.
   * @param {string} parameters.'x-profile-instance-id' - Profile Instance ID
   * @param {string} [parameters.'x-request-id'] - Request Id
   * @returns {Promise<Response>} the response
   */
  patchConfigMergePoliciesMergePolicyId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Delete a merge policy by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.mergePolicyId - Merge policy ID.
   * @param {string} [parameters.'x-request-id'] - Request Id
   * @returns {Promise<Response>} the response
   */
  deleteConfigMergePoliciesMergePolicyId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup an entity by ID or namespace.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'schema.name' - XED schema class name.
   * @param {string} [parameters.'relatedSchema.name'] - XDM schema class name that the ExperienceEvent is associated with. Used when looking up ExperienceEvents.
   * @param {string} [parameters.entityId] - ID of the entity. For Native XID lookup, use `entityId=<XID>` and leave `entityIdNS` absent; For ID:NS lookup, use both `entityId` and `entityIdNS` fields.
   * @param {string} [parameters.entityIdNS] - Identity Namespace code. Used for ID:NS lookup. If this field is used, `entityId` cannot be empty.
   * @param {string} [parameters.relatedEntityId] - ID of the entity that the ExperienceEvents are associated with. Used when looking up ExperienceEvents. For Native XID lookup, use `relatedEntityId=<XID>` and leave `relatedEntityIdNS` absent; For ID:NS lookup, use both `relatedEntityId` and `relatedEntityIdNS` fields.
   * @param {string} [parameters.relatedEntityIdNS] - Identity Namespace code of the related entity ID of ExperienceEvent. Used when looking up ExperienceEvents. If this field is used, `entityId` cannot be empty.
   * @param {string} [parameters.fields] - Fields for the model object. By default, all fields will be fetched. Separated by comma.
   * @param {string} [parameters.mergePolicyId] - ID of the merge policy. A merge policy includes information for Identity stitching and key-value XDM object merging. If not present, the default merge policy will be used.
   * @param {number} [parameters.startTime] - Start time of Time range filter for ExperienceEvents. Should be at millisecond granularity. Included. Default: From beginning.
   * @param {number} [parameters.endTime] - End time of Time range filter for ExperienceEvents. Should be at millisecond granularity. Excluded. Default: To the end.
   * @param {number} [parameters.limit] - Number of records to return from the result. Only for time-series objects. Default: 1000
   * @param {string} [parameters.orderby] - The sort order of retrieved ExperienceEvents by timestamp. Syntax: (+/-)timestamp. Default: +timestamp
   * @returns {Promise<Response>} the response
   */
  getAccessEntities (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup multiple entities by IDs or namespaces.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'Content-Type' - Type of content being sent in the body of the request. Should be 'application/json'.
   * @returns {Promise<Response>} the response
   */
  postAccessEntities (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Delete an entity by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'schema.name' - Name of the associated XDM schema.
   * @param {string} [parameters.entityId] - ID of the entity. For Native XID, use `entityId=<XID>` and leave `entityIdNS` absent; For ID:NS, use both `entityId` and `entityIdNS` fields.
   * @param {string} [parameters.entityIdNS] - Identity Namespace code. Used for ID:NS. If this field is used, `entityId` cannot be empty.
   * @param {string} [parameters.mergePolicyId] - ID of the merge policy. A merge policy includes information for Identity stitching and key-value XDM object merging. If not present, the default merge policy will be used.
   * @returns {Promise<Response>} the response
   */
  deleteAccessEntities (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Retrieve a list of all export jobs.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {number} [parameters.limit] - Limit the number of export jobs returned in the list.
   * @param {string} [parameters.offset] - Offset the page of results returned (ordered by created time of resource)
   * @param {string} [parameters.status] - Filter the export jobs returned by job status. Possible values are "NEW", "SUCCEEDED", and "FAILED".
   * @returns {Promise<Response>} the response
   */
  getScanJobsRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create a new export job.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'Content-Type' - Type of content being sent in the body of the request. Should be 'application/json'.
   * @param {string} [parameters.'x-profile-instance-id'] - Profile Instance ID
   * @returns {Promise<Response>} the response
   */
  postScanJobRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup an export job by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.exportJobId - Export job ID
   * @returns {Promise<Response>} the response
   */
  getScanJobRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Cancel or delete an export job by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.exportJobId - Export job ID
   * @returns {Promise<Response>} the response
   */
  cancelScanJobRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Retrieve a list of segment definitions.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'x-request-id' - Unique ID per request
   * @param {number} [parameters.start] - Page offset - As per created time of resource
   * @param {number} [parameters.limit] - Page size
   * @param {number} [parameters.page] - Page number
   * @param {string} [parameters.sort] - Sort parameters
   * @returns {Promise<Response>} the response
   */
  getSegmentsRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create a new segment definition.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'Content-Type' - Type of content being sent in the body of the request. Should be 'application/json'.
   * @param {string} parameters.'x-request-id' - Unique ID per request
   * @returns {Promise<Response>} the response
   */
  postSegmentRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup a segment definition by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.segmentId - Segment Definition ID.
   * @param {string} parameters.'x-request-id' - Unique ID per request
   * @returns {Promise<Response>} the response
   */
  getSegmentRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Delete a segment definition by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.segmentId - Segment Definition ID.
   * @param {string} parameters.'x-request-id' - Unique ID per request
   * @returns {Promise<Response>} the response
   */
  deleteSegmentRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Overwrite a segment definition.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.segmentId - Segment Definition ID.
   * @param {string} parameters.'Content-Type' - Type of content being sent in the body of the request. Should be 'application/json'.
   * @param {string} parameters.'x-request-id' - Unique ID per request
   * @returns {Promise<Response>} the response
   */
  patchSegmentRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Convert PQL formatting between pql/text and pql/json.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'Content-Type' - Type of content being sent in the body of the request. Should be 'application/json'.
   * @param {string} parameters.'x-request-id' - Unique ID per request
   * @returns {Promise<Response>} the response
   */
  postSegmentConversionRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Retrieve a list of all segment job requests.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} [parameters.'x-request-id'] - Request ID
   * @param {number} [parameters.start] - Page Offset - As per created Time of resource
   * @param {number} [parameters.limit] - Page Size
   * @param {string} [parameters.status] - The job status
   * @returns {Promise<Response>} the response
   */
  getSegmentJobs (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create a new segment job request.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'Content-Type' - Type of content being sent in the body of the request. Should be 'application/json'.
   * @param {string} parameters.'x-profile-instance-id' - Profile Instance ID
   * @param {string} [parameters.'x-request-id'] - Request ID
   * @returns {Promise<Response>} the response
   */
  postSJRRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup a segment job request by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.segmentJobId - Segment job request ID.
   * @param {string} [parameters.'x-request-id'] - Request ID
   * @returns {Promise<Response>} the response
   */
  getSegmentJobsSegmentJobId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Cancel or delete a segment job request by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.segmentJobId - Segment job request ID.
   * @param {string} [parameters.'x-request-id'] - Request ID
   * @returns {Promise<Response>} the response
   */
  deleteSegmentJobsSegmentJobId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create a new preview job.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'Content-Type' - Type of content being sent in the body of the request. Should be 'application/json'.
   * @returns {Promise<Response>} the response
   */
  postSessionlessPreviewRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup the results of a preview job by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.previewId - ID of the preview job.
   * @param {string} [parameters.offset] - Page offset
   * @param {number} [parameters.limit] - How many entries should be present in a page. 1000 if not specified.
   * @returns {Promise<Response>} the response
   */
  getSessionlessPreviewStatusRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Cancel or delete a preview job by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.previewId - ID of the preview job.
   * @returns {Promise<Response>} the response
   */
  deleteSessionLessPreviewStatusRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup the results of an estimate job by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.previewId - ID of the preview job.
   * @returns {Promise<Response>} the response
   */
  getEstimateStatusRoute (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Retrieve a list of edge projection configurations. The latest definitions are returned.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'x-gw-ims-authorization' - Gateway IMS service token.
   * @param {string} [parameters.schemaName] - XDM schema name
   * @param {string} [parameters.name] - projection name
   * @param {string} [parameters.'x-user-token'] - User access token.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a client flow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  listProjectionConfigurations (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create a new edge projection configuration.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.schemaName - XDM schema name
   * @param {string} parameters.'x-gw-ims-authorization' - Gateway IMS service token.
   * @param {string} [parameters.'x-user-token'] - User access token.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a client flow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  createProjectionConfiguration (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup an edge projection configuration by ID. The latest definition is returned.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.projectionid - undefined
   * @param {string} parameters.'x-gw-ims-authorization' - Gateway IMS service token.
   * @param {string} [parameters.'x-user-token'] - User access token.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a client flow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  getProjectionConfiguration (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create or update an edge projection configuration by ID. Overwrites the entire configuration.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.projectionid - undefined
   * @param {string} parameters.'x-gw-ims-authorization' - Gateway IMS service token.
   * @param {string} [parameters.'x-user-token'] - User access token.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a client flow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  updateProjectionConfiguration (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Delete an edge projection configuration by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.projectionid - undefined
   * @param {string} parameters.'x-gw-ims-authorization' - Gateway IMS service token.
   * @param {string} [parameters.'x-user-token'] - User access token.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a client flow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  deleteProjectionConfiguration (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Retrieve a list of edge projection destinations. The latest definitions are returned.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a workflow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  listProjectionDestinations (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create a new edge projection destination.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'x-gw-ims-authorization' - Gateway IMS service token.
   * @param {string} [parameters.'x-user-token'] - User access token.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a client flow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  createProjectionDestination (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup an edge projection destination by ID. The latest definition is returned.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.destinationId - undefined
   * @param {string} parameters.'x-gw-ims-authorization' - Gateway IMS service token.
   * @param {string} [parameters.'x-user-token'] - User access token.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a client flow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  getProjectionDestination (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create or update an edge projection destination by ID. Overwrites the entire configuration.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.destinationId - undefined
   * @param {string} parameters.'x-gw-ims-authorization' - Gateway IMS service token.
   * @param {string} [parameters.'x-user-token'] - User access token.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a client flow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  putProjectionDestination (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Delete an edge projection destination by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.destinationId - undefined
   * @param {string} parameters.'x-gw-ims-authorization' - Gateway IMS service token.
   * @param {string} [parameters.'x-user-token'] - User access token.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a client flow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  deleteProjectionDestination (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Retrieve a list of event types.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a workflow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @param {number} [parameters.start] - Page offset for the response. Default is 0.
   * @param {number} [parameters.limit] - Page size
   * @param {string} [parameters.orderBy] - The model attribute to be used for ordering.
   * @returns {Promise<Response>} the response
   */
  getConfigEventTypes (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create a new event type.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'x-profile-instance-id' - Profile instance ID.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a workflow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  postConfigEventTypes (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup an event type by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.eventTypeId - Event type ID.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a workflow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  getConfigEventTypesEventTypeId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Overwrite an event type by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.eventTypeId - Event type ID.
   * @param {string} parameters.'x-profile-instance-id' - Profile instance ID.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a workflow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  putConfigEventTypesEventTypeId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Update one or more attributes of an event type by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.eventTypeId - Event type ID.
   * @param {string} parameters.'x-profile-instance-id' - Profile instance ID.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a workflow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  patchConfigEventTypesEventTypeId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Delete an event type by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.eventTypeId - Event type ID.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a workflow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  deleteConfigEventTypesEventTypeId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Retrieve a list of all macros for your organization.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} [parameters.'x-request-id'] - Request ID
   * @param {string} [parameters.start] - Page offset (at the created time of resource)
   * @param {number} [parameters.limit] - Maximum number of objects to display on each page.
   * @param {string} [parameters.orderBy] - Model attribute which will be using for ordering.
   * @param {string} [parameters.dataSetId] - Dataset ID.
   * @param {string} [parameters.schemaClassId] - Schema class ID.
   * @param {string} [parameters.value] - Event type value.
   * @returns {Promise<Response>} the response
   */
  getConfigMacros (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create a new macro.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'x-profile-instance-id' - Profile Instance ID
   * @param {string} [parameters.'x-request-id'] - Request ID
   * @returns {Promise<Response>} the response
   */
  postConfigMacros (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup a macro by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.macroId - Macro ID. For example, `ca8fe8a8-0f38-478a-9905-fd515d1d2988`
   * @param {string} [parameters.'x-request-id'] - Request Id
   * @returns {Promise<Response>} the response
   */
  getConfigMacrosMacroId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Overwrite a macro by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.macroId - Macro ID. For example, `ca8fe8a8-0f38-478a-9905-fd515d1d2988`
   * @param {string} parameters.'x-profile-instance-id' - Profile Instance ID
   * @param {string} [parameters.'x-request-id'] - Request ID
   * @returns {Promise<Response>} the response
   */
  putConfigMacrosMacroId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Update a macro by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.macroId - Macro ID. For example, `ca8fe8a8-0f38-478a-9905-fd515d1d2988`
   * @param {string} parameters.'x-profile-instance-id' - Profile Instance ID.
   * @param {string} [parameters.'x-request-id'] - Request ID.
   * @returns {Promise<Response>} the response
   */
  patchConfigMacrosMacroId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Delete a macro by ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.macroId - Macro ID. For example, `ca8fe8a8-0f38-478a-9905-fd515d1d2988`
   * @param {string} [parameters.'x-request-id'] - Request ID.
   * @returns {Promise<Response>} the response
   */
  deleteConfigMacrosMacroId (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Retrieve a list of schedules for your IMS Org
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a workflow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @param {number} [parameters.start] - Return results from a specific page offset. For example, `start=3`
   * @param {number} [parameters.limit] - Limit response to a specific number of objects. Must be a positive number. For example, `limit=10`
   * @returns {Promise<Response>} the response
   */
  getSchedules (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create a schedule, including specifying the time when the schedule should be triggered.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'Content-Type' - Type of content being sent in the body of the request. Should be 'application/json'.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a workflow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  createSchedule (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Lookup a schedule by its ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.SCHEDULE_ID - The ID of the schedule against which the operation is being performed.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a workflow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  getScheduleById (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Update a schedule, including changing the trigger time or enabling/disabling the schedule.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.SCHEDULE_ID - The ID of the schedule against which the operation is being performed.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a workflow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  updateSchedule (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Delete a schedule by its ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.SCHEDULE_ID - The ID of the schedule against which the operation is being performed.
   * @param {string} [parameters.'x-request-id'] - Optional header that may be used for debugging purposes when investigating issues with a workflow. The same ID can be used to identify a single request to the service from a flow. A new ID should be created for each request.
   * @returns {Promise<Response>} the response
   */
  deleteSchedule (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Retrieve a list of all delete requests (Profile System Jobs) created by your organization.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {number} [parameters.start] - Return results from a specific page offset. For example, `start=3`
   * @param {number} [parameters.limit] - Limit response to a specific number of objects. Must be a positive number. For example, `limit=10`
   * @param {number} [parameters.page] - Return a specific page of results, as per the create time of the request. For example, `page=0`
   * @param {string} [parameters.sort] - Sort results by a specific field in ascending (`asc`) or descending (`desc`) order. The sort parameter does not work when returning multiple pages of results. For example, `sort=batchId:asc`
   * @returns {Promise<Response>} the response
   */
  listDeleteRequests (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Create a delete request (Profile System Job)
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.'Content-Type' - Type of content being sent in the body of the request. Should be 'application/json'.
   * @returns {Promise<Response>} the response
   */
  createDeleteRequest (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * View a specific delete request (Profile System Job) by its ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.ID - ID of the delete request (Profile System Job) that you wish to view. For example, '3e64ad31-5e6b-4399-80ad-ccfab54254ae'.
   * @returns {Promise<Response>} the response
   */
  viewDeleteRequest (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
  /**
   * Remove a specific delete request (Profile System Job) by its ID.
   *
   * @param {object} [parameters={}] - parameters to pass
   * @param {string} parameters.ID - ID of the delete request (Profile System Job) that you wish to view. For example, '3e64ad31-5e6b-4399-80ad-ccfab54254ae'.
   * @returns {Promise<Response>} the response
   */
  deleteDeleteRequest (parameters = {}) {
    return new Promise((resolve, reject) => {})
  }
  
}
